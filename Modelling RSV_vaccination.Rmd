---
title: "Modelling for RSV"
author: "Phuong Huynh Thi"
date: "24/03/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

#Setting
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list=ls())
setwd("/home/phuong/phuonght/gitKraken_project/RSV")
library(deSolve)
library(ggplot2)

#Changeable variables  ##########################
#vaccinnation overage = c+c1 (20%, 40%,)
#coverage = 0.2 # 0.2,0.4 
p = 0       # vaccinate a fraction p of newborn 
p1= 0
# vaccinate a fraction p of AG1 ( aged< 1 year)
e = 0.7              # vaccine efficacy is 70%
t_shift = 461        # optimized from fitting# this change up to what fitted set of params
t_vac = 37           # wk29,33,37 ## vaccinating 3,2,1 month before the epidemic season starts at week 41st. 
vac.str = "year-round" # year-round or seasonal vaccination strategy will be applied.
#7 epidemic years was fitted. An epidemic year will start from week 33 to week 32 next year
#week0 (fitting curve)= week 33 of calendar year
#vaccine period: week 33 to week 8 next year = 28wks
#year 2016: 53 weeks??
vac.period <- (52-t_vac+1+8)/52 # start vaccination from week 't_vac" this year to week 8 next year
report_rate       <- 67.5/100   #assuming only 67.5 of RVS incidence are reported with those aged < 1
#vaccine coverage
cov.sea       <- p*vac.period + p1*(1-p*vac.period)*vac.period
cov.yr        <- p + p1*(1-p)

```

# Parameters
```{r}
######################################### #
# POPULATION AND PARAMETERS  ----
######################################### #
#https://steemit.com/science/@fouad/x-history-of-math-symbols
pop_size          <- 11176549# Belgium pop size (average 2011-2018)
ag1_size          <- pop_size*1/80
ag2_size          <- pop_size - ag1_size
num_days          <- 500
num_weeks         <- 52*30
num_days_infected <- 10  #[ 8-11], 6.7 is original estimate
num_days_exposed  <- 4   # [2,6]
num_days_waning   <- 200 # [148, 164] best fit
infected_seeds    <- 100# ? 1= 1000 1% of children ??? 

# the fitted parameters may be different between population size
  # set parameters
  params     <- c(sigma = 7/num_days_exposed,  #latent to infectious stage
                  # sigma = 1/0.57,              # latent to infectious stage
                  gamma = 7/num_days_infected,# recovery rate
                  # gamma = 1/1.4,               # recovery rate
                  # nu=  7/num_days_waning,     # rate of loss of immunity
                  nu=  0.037,                  # rat e of loss of immunity
                  eta1 = 1/(1*52),             # aging rate AG1
                  eta2 = 1/(79*52),            # aging rate AG2
                  omega = 1/(2),               #vaccination rate # time to have immunity after vaccination : 7-14 days -> 10 days?
                  mu = 1/(80*52),              # birth rate
                  a = 0.88,                    # the degree of seasonality, range [0,1]
                  phi = 3.1,                   # phase shift?
                  b = 1.82,                    #average transmission rate
                  delta = 0.65,                # scaled susceptibility
                  alpha = 0.65                 # scaled infectiousness
  )
  # sigma = 1/0.57,gamma = 1/1.4
    # plot_model_fit(c(1.85,0.85,3.1,-357,0.032)) #21605.41
  #sigma = 7/num_days_exposed, gamma = 7/num_days_infected
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.038)) # 20915.97 => using
   # plot_model_fit(c(1.82,0.88,3.1,-461,0.037)) # 18337.04 # consider
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.037)) # 21000.11
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.039)) # 23207.43    
   # plot_model_fit(c(1.82,0.875,3.1,-462,0.034))# 22313.57
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.039)) # 23207.43
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.036)) # 24552.02
   
  
```

# SEIRS with differnt intervention scenarios.
*Vaccination period*
   vac.period <- (52-t_vac+1+8)/52
      where t_vac= wk29,33,37 ## vaccinating 3,2,1 month before the epidemic season starts at week 41st to end of the epidemic season at week 8. 

*Vaccination target*
p indicates newborn
p1 indicates those aged < 1

*Vaccine coverage*
cov.sea       <- p*vac.period + p1*(1-p*vac.period)*vac.period
cov.yr        <- p + p1*(1-p)


```{r Model structure, echo=T, eval=T}
#eval = F: preventing running codes

  #sum total population =1
  S1 <- 1/80 # less than 1 yrs old
  E1 <- (infected_seeds*0.7)/(pop_size)
  I1 <- 0
  R1 <- 0
  V1  <- 0
  E2 <- (infected_seeds*0.3)/(pop_size) # greater than 1 yrs old
  I2 <- 0
  R2 <- 0
  S2 <- 1-S1-E1-I1-R1-E2-I2-R2-V1 

######################################### #
# SET FUNCTION PARAMETERS            ----
######################################### #
# set time frame
times      <- seq(0, num_weeks, by = 1)
# set initial health states
states     <- c(S1 = S1,E1 = E1, I1 = I1, R1 = R1, V1 = V1,
                S2 = S2,E2 = E2, I2 = I2, R2 = R2)
######################################### #
# CREATE SIRV FUNCTION               ----
######################################### #
# Note: updating the health states over time and keeping track of the changes, is handled by the
# ode-function of the 'deSolve' package.
sirv_func <- function(t, states, params) {
  
  with(as.list(c(states, params)),
       {
         # define variables
         beta <- b*(1+a*cos(2*pi*t/52+phi))
         
         if(vac.str=="year-round"){
           # vaccinate year-round
           if(t<(t_shift)){
             p  <- 0
             p1 <- 0
           }else {
             p  <- p
             p1 <- p1
           }
         }
         if(vac.str=="seasonal"){
           # Vaccinate seasonal: 3,2,1 months before the the epidemic season start
           if(t< (t_shift+t_vac)){# skip 't_vac' wks of 
             p  <- 0
             p1 <- 0
           }
           if(t>= (t_shift +t_vac)){# start vaccination epidemic season 2011/2012
             t_week = (t-t_shift)%%52
             if(floor(t_week) >= t_vac|floor(t_week) <= 8){
               p  <- p
               p1 <- p1 
             }else{
               p  <- 0
               p1 <- 0
             }
           } 
         }
         
         # calculate state changes
         dS1 <- (1-p*e)*mu  - beta*S1*(I1+alpha*I2)  + nu*R1                - eta1*S1 - p1*e*omega*S1
         dE1 <-               beta*S1*(I1+alpha*I2)  - sigma*E1             - eta1*E1
         dI1 <-                                        sigma*E1  - gamma*I1 - eta1*I1
         dR1 <-                                      - nu*R1     + gamma*I1 - eta1*R1 
         
         dV1 <- p*e*mu - eta1*V1 + p1*e*omega*S1
         
         dS2 <- eta1*V1 +eta1*S1 - delta*beta*S2*(I1+alpha*I2) + nu*R2                - eta2*S2 
         dE2 <-          eta1*E1 + delta*beta*S2*(I1+alpha*I2) - sigma*E2             - eta2*E2 
         dI2 <-          eta1*I1                               + sigma*E2 - gamma*I2  - eta2*I2 
         dR2 <-          eta1*R1                               - nu*R2    + gamma*I2  - eta2*R2 
         
         # return (dS, dI, dR) as a vector in a list (required for the 'solve' function)
         return(list(c(dS1, dE1, dI1, dR1,dV1, dS2, dE2, dI2, dR2)))
       }
  )
}

```

#ODE
```{r ODE, echo=T, eval=T}
#eval = F: preventing running codes
######################################### #
# SOLVE ODE                          ----
######################################### #
# use the 'ode' function of deSolve package with our SIR function, health states and parameters
out <- ode(func = sirv_func, y = states, times = times, parms = params)
plot(out)
# summary(out)
# times_output <- seq(num_weeks-(52*8)-2,num_weeks,1)# burning time ## shifting peaks
times_output <- seq(num_weeks-(num_weeks-t_shift),num_weeks,1)# burning time ## shifting peaks
# times_output <- times_output[1:346]# take exactly 8 years (378-32 wks) for later fitting data
times_output <- times_output[1:(52*11)]# show model in 11 yrs
out <- out[out[,1] %in% times_output,] # skip the initial time points
out[,1] <- out[,1] - min(out[,1])# rescale time points : t_shift +1 ~ 0
######################################### #
# PLOT RESULTS                       ----
######################################### #
# convert the 'out' matrix into a data-frame (to enable the use of '$' to access a column by name)
out <- as.data.frame(out)
out$S <- out[,"S1"] + out[,"S2"]
out$E <- out[,"E1"] + out[,"E2"]
out$I <- out[,"I1"] + out[,"I2"]
out$R <- out[,"R1"] + out[,"R2"]
out$V <- out[,"V1"]
pop <- out$S + out$E +out$I + out$R + out$V
# Vaccination dose
dose_yearly.newborn <- floor(cov.annual.newborn*ag1_size*10)
dose_yearly.both <- floor(cov.annual.both*ag1_size*10)
dose_seasonal.newborn <- floor(cov.sea.newborn*ag1_size*10) 
dose_seasonal.both <- floor(cov.sea.both*ag1_size*10) 
##Number of each epidemic year
ag1_est_year1 <- sum(floor(out$I1[33:(33+51)]*pop_size))#year 2011-2012
ag1_est_year2 <- sum(floor(out$I1[85:(85+51)]*pop_size))
ag1_est_year3 <- sum(floor(out$I1[137:(137+51)]*pop_size))
ag1_est_year4 <- sum(floor(out$I1[189:(189+51)]*pop_size))
ag1_est_year5 <- sum(floor(out$I1[241:(241+51)]*pop_size))
ag1_est_year6 <- sum(floor(out$I1[293:(293+51)]*pop_size))
ag1_est_year7 <- sum(floor(out$I1[345:(345+51)]*pop_size))
ag1_est_year8 <- sum(floor(out$I1[397:(397+51)]*pop_size))
ag1_est_year9 <- sum(floor(out$I1[449:(449+51)]*pop_size))
ag1_est_year10 <- sum(floor(out$I1[501:(501+51)]*pop_size))
case <- data.frame(c(ag1_est_year1,
                    ag1_est_year2,
                    ag1_est_year3,
                    ag1_est_year4,
                    ag1_est_year5,
                    ag1_est_year6,
                    ag1_est_year7,
                    ag1_est_year8,
                    ag1_est_year9,
                    ag1_est_year10))
case$year <- seq(1:10)
colnames(case)              <- c("case.a.year","year")
#Total number of infected
ag1_est <- floor(out$I1[33:552]*pop_size)# 10 epidemic years
ag1_est_sum <- sum(ag1_est)
case$ag1_est                <- rep(ag1_est_sum,10)
case$dose_yearly.newborn    <- rep(dose_yearly.newborn,10)
case$dose_yearly.both       <- rep(dose_yearly.both,10)
case$dose_seasonal.newborn  <- rep(dose_seasonal.newborn,10)
case$dose_seasonal.both     <- rep(dose_seasonal.both,10)
#saving file
if(vac.str=="seasonal"){
  write.csv(case, paste("/home/phuong/Dropbox/2.Master of Epidemiology_Antwerp/year 2/thesis/data analysis/csv_file/sumcase.est.yearly p=",p,"p1=",p1,vac.str,"wk",t_vac,".csv"))
}
if(vac.str=="year-round"){
  write.csv(case, paste("/home/phuong/Dropbox/2.Master of Epidemiology_Antwerp/year 2/thesis/data analysis/csv_file/sumcase.est.yearly p=",p,"p1=",p1,vac.str,".csv"))
}


#BELGIUM DATA-----------------
case_dt <- read.csv("./RSV data/RSV_cases_time_epistat.csv")
case_dt$week      <- seq(1,dim(case_dt)[1])
age_dt <- read.csv("./RSV data/RSV_cases_age_epistat.csv")
# total cases: 63301,4yrs: 822,3yr:1794,2yr:4559 1yr:13751,0yr:42375
pro.less1yr  <- age_dt$cases[age_dt$age==0] / sum(age_dt$cases) 
case_dt$cases_ag1 <- round(case_dt$cases*pro.less1yr)
case_dt$cases_ag2 <- case_dt$cases - case_dt$cases_ag1
#Assuming only 67.5% incidence was reported
case_dt$cases_scaled <- round(case_dt$cases/0.675)
case_dt$cases_ag1_scaled <- round(case_dt$cases_ag1/0.675)
case_dt$cases_ag2_scaled <- case_dt$cases_scaled - case_dt$cases_ag1_scaled
  
######################################### #
# Plot Model fit                      ----
######################################### #
# plot real data
par(mfrow = c(1,1))
plot(case_dt$week, # plot seasonal 
     case_dt$cases_ag1,
     xlab = "Time (weeks)",
     ylab = "Number of RSV reported",
     pch=19,col=1,
     ylim = c(0, max(case_dt$cases_ag1)*1.2),
     xaxt="none")# for later customizing
axis(1,seq(0,350,by=50))# customize x-axis
# plot initial model
lines(out$time[1:length(case_dt$cases_ag1)],out$I1[1:length(case_dt$cases_ag1)]*pop_size*report_rate,col=2,lwd=2,type = "b",pch=1)
legend(309,1200, legend = c("observed","model fit"), col = c(1,2),lty=1:2,pch=c(19,1))
# score for initial model
get_sum_of_squares(out$I1[1:length(case_dt$cases)]*pop_size,case_dt$cases_ag1)

# Vaccination effect:
par(mfrow = c(1,1))
plot(out$time, # plot seasonal 
     out$I1*pop_size,
     xlab = "Year",
     ylab = "Number of RSV infection",
     main= paste("Vaccination p =",p,"p1=",p1,vac.str,"wk",t_vac),col=2,type = "l",lwd=2,
     xlim = c(0,52*10),
     xaxt="none")# for later customizing
axis(1, at=seq(0,520,by=52),labels = c(0:10))

# # Vaccination effect
# par(mfrow = c(1,1))
# plot(out$time, # plot seasonal
#      out$I1*pop_size,
#      xlab = "Year",
#      ylab = "Number of RSV infection",
#      main= paste("Vaccination fraction =",p),col=2,type = "l",lwd=2,
#      xlim = c(0,52*10),
#      xaxt="none")# for later customizing
# axis(1, at=seq(0,520,by=52),labels = c(0:10))

```

# Optimizing parameters
##original report data 
###Least square

```{r Fitting, echo=T, eval=F}
#eval = F: preventing running codes
######################################### #
# Parameters optimizations                      ----
######################################### #
# DEFINE HELP FUNCTION TO CALCULATE SUM OF SQUARES
get_sum_of_squares <- function(model_values,ref_values) {
  return(sum(sqrt((model_values-ref_values)^2)))
}
# SET GOAL: to use the optimisation package
library(Rcpp)
library(optimization)
#DEFINE FUNCTION TO RUN ODE WITH PARAMETER VECTOR X
x <- c(1.82, 0.76,2.8,461,0.03) #b[?] a(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
get_model_output <- function(x){
  # params_fitting
  params_fit = params
  params_fit["b"] = x[1]
  params_fit["a"] = x[2]
  params_fit["phi"] =   x[3]
  time_shift =x[4]
  params_fit["nu"] = x[5]
  # get output
  out <- data.frame(ode(func = sirv_func, y = states, times = seq(0,num_weeks,1), parms = params_fit))
  # shift in time (fill with 0)
  out <- approx(x   = out$time - time_shift,
                y   = out$I1,
                xout = seq(0,num_weeks,1), # only extract y where x in this seq
                rule = 1)  # NAs is returned as it is
  names(out) <- c('time','I1')
  # rescale time points
  out$time <- out$time - min(out$time)
  # return output
  return(out)
}
# HELP FUNCTION TO CALCULATE SUM OF SQUARES GIVEN PARAMETERS 'X'
get_parameter_score <- function(x) {
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score
  model_score <- get_sum_of_squares(model_out$I1*pop_size,case_dt$cases_ag1)
  # return model score
  return(model_score)
}
# HELP FUNCTION TO VISUALIZE THE MODEL FITTING
plot_model_fit <- function(x){
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score
  model_score <- get_sum_of_squares(model_out$I1[1:length(case_dt$cases)]*pop_size,case_dt$cases_ag1)
  # plot reference data
  plot(case_dt$week,
       case_dt$cases_ag1,
       ylim = c(0,max(case_dt$cases_ag1)*2),type = "b",pch=19,
       main = paste('score:',round(model_score,digits = 2)))
  # plot initial model
  lines(model_out$time,model_out$I1*pop_size,col=2,lwd=1,type = "b")
}
##Optimizing parameters, by specifing lower and upper values
# beta0[?] beta1(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
# opt_param_sa <- optim_sa(fun = get_parameter_score, start = c(1.8,0.1,1,-200,7/350),
#                          trace = FALSE,
#                          lower = c(1,0,1,-1000,7/350),#
#                          upper = c(3,1,3,-100,7/160),
#                          control = list(dyn_rf = F,
#                                         rf = 1,
#                                         t0 = 1000, nlimit = 100, r = 0.6, t_min = 0.1
#                          ))$par
# 
# opt_param_sa
# plot_model_fit(opt_param_sa)
################################# #
#report data 100%----------------
################################# #
# sigma = 1/0.57,gamma = 1/1.4
    # plot_model_fit(c(1.85,0.85,3.1,-357,0.032)) #21605.41
  #sigma = 7/num_days_exposed, gamma = 7/num_days_infected
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.038)) # 20915.97
   # plot_model_fit(c(1.82,0.875,3.1,-462,0.034))# 22313.57
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.039)) # 23207.43
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.036)) # 24552.02
   # plot_model_fit(c(1.82,0.88,3.1,-461,0.037)) # 18337.04 # consider
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.037)) # 21000.11
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.039)) # 23207.43 #
   # plot_model_fit(c(1.82,0.87,3.1,-462,0.036)) # 23207.43 #
   # plot_model_fit(c(1.82,0.88,3.1,-462,0.036)) # 24552.02
   

```

## 67.5% Scaling report data 
### Least square
Assuming 67.5% RSV cases are reported as the same rate of rotavirus.

```{r Fitting, echo=T, eval=F}
#eval = F: preventing running codes

######################################### #
# Parameters optimizations                      ----
######################################### #
# DEFINE HELP FUNCTION TO CALCULATE SUM OF SQUARES
get_sum_of_squares <- function(model_values,ref_values) {
  return(sum(sqrt((model_values-ref_values)^2)))
}
# SET GOAL: to use the optimisation package
library(Rcpp)
library(optimization)
#DEFINE FUNCTION TO RUN ODE WITH PARAMETER VECTOR X
x <- c(1.82, 0.76,2.8,515,0.03) #b[?] a(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
get_model_output <- function(x){
  # params_fitting
  params_fit = params
  params_fit["b"] = x[1]
  params_fit["a"] = x[2]
  params_fit["phi"] =   x[3]
  time_shift =x[4]
  params_fit["nu"] = x[5]
  # get output
  out <- data.frame(ode(func = sirv_func, y = states, times = seq(0,num_weeks,1), parms = params_fit))
  # shift in time (fill with 0)
  out <- approx(x   = out$time - time_shift,
                y   = out$I1,
                xout = seq(0,num_weeks,1),
                rule = 1) # NAs is returned as it is
  names(out) <- c('time','I1')
  # rescale time points
  out$time <- out$time - min(out$time)
  # return output
  return(out)
}
# HELP FUNCTION TO CALCULATE SUM OF SQUARES GIVEN PARAMETERS 'X'
get_parameter_score <- function(x) {
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score
 model_score <- get_sum_of_squares(model_out$I1[1:length(case_dt$cases_ag1)]*pop_size*report_rate,case_dt$cases_ag1)
  # return model score
  return(model_score)
}
#OPTIMIZING PARAMETERS, by specifing lower and upper values
# beta0[?] beta1(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
opt_param_sa <- optim_sa(fun = get_parameter_score, start = c(1.8,0.65,3.15,200,7/200),
                         trace = FALSE,
                         lower = c(1.7,0.1,3,50,7/230),#
                         upper = c(2,0.9,4,600,7/160),
                         control = list(dyn_rf = F,
                                        rf = 1,
                                        t0 = 1000, nlimit = 100, r = 0.6, t_min = 0.1
                         ))$par

opt_param_sa

# HELP FUNCTION TO VISUALIZE THE MODEL FITTING
plot_model_fit <- function(x){
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score
  model_score <- get_sum_of_squares(model_out$I1[1:length(case_dt$cases_ag1)]*pop_size*report_rate,case_dt$cases_ag1)
  # plot reference data
  plot(case_dt$week,
       case_dt$cases_ag1,
       ylim = c(0,max(case_dt$cases_ag1)*2),type = "b",pch=19,
       xlim=c(0,500),
       main = paste('LS:',round(model_score,digits = 2),
                    "b:",opt_param_sa[1],
                    "a:",opt_param_sa[2],
                    "phi:",opt_param_sa[3],
                    "t_shift:",opt_param_sa[4],
                    "nu:",opt_param_sa[5]))
  # plot initial model
  lines(model_out$time,model_out$I1*pop_size*report_rate,col=2,lwd=1,type = "b")
}

plot_model_fit(opt_param_sa)

# [1]   1.813   0.845   3.280 199.060   0.035 # 17662.05
# [1]   1.833   0.885   3.100 200.780   0.035 # 17318.9

get_parameter_score(c(1.81809030,0.82631195, 3.96459003, 90.76895906,0.03642838))


  
```

### Poisson likelihood

```{r Fitting, echo=T, eval=T}
#eval = F: preventing running codes

######################################### #
# Parameters optimizations                      ----
######################################### #

# SET GOAL: to use the optimisation package
library(Rcpp)
library(optimization)
#DEFINE FUNCTION TO RUN ODE WITH PARAMETER VECTOR X
x <- c(log(1.82),log( 0.88),log(3.1),log(461), log(0.037)) #b[?] a(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
get_model_output <- function(x){
  # params_fitting
  params_fit = params
  params_fit["b"] = exp(x[1])
  params_fit["a"] = exp(x[2])
  params_fit["phi"] =   exp(x[3])
  time_shift = exp(x[4])
  params_fit["nu"] = exp(x[5])
  # get output
  out <- data.frame(ode(func = sirv_func, y = states, times = seq(0,num_weeks,1), parms = params_fit))
  # shift in time (fill with 0)
  out <- approx(x   = out$time - time_shift,
                y   = out$I1,
                xout = seq(0,num_weeks,1),
                rule = 1) # NAs is returned as it is
  names(out) <- c('time','I1')
  # rescale time points
  out$time <- out$time - min(out$time)
  # return output
  return(out)
}


# HELP FUNCTION TO CALCULATE Negative log likelihood GIVEN PARAMETERS 'X'
get_parameter_score <- function(x) {
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score
  # inc <- model_out$I1*pop_size
  # time<- model_out$time
  
  L<-matrix(0,nrow=length(case_dt$cases),ncol=1)
  
  #Obtains the likelihood from the model
  L<-dpois(case_dt$cases_ag1,model_out$I1[1:length(case_dt$cases_ag1)]*pop_size*report_rate,log=TRUE)
  
  #Log likelihood
  LL<-sum((1-(L==-Inf))*L,na.rm=TRUE)
  
  #Negative log likelihood
  NLL<--LL
  
  # return model score
  return(NLL)
}

#OPTIMIZING PARAMETERS, by specifing lower and upper values, by specifing lower and upper values
# # beta0[?] beta1(0,1],phi[1,2],shifting time, nu[1/160,1/230]#160-230 days
opt_param_sa <- optim_sa(fun = get_parameter_score, start = c(log(1.83),log(0.8),log(3.15),log(300),log(7/200)),
                         trace = T,
                         lower = c(log(1.8),log(0.1),log(2),log(50),log(7/230)),
                         upper = c(log(2),log(1),log(4),log(600),log(7/160)),
                         control = list(dyn_rf = T,#change dynamically over time
                                        rf = 1,
                                        t0 = 1000, nlimit = 100, r = 0.6, t_min = 0.1
                         ))$par

par<- opt_param_sa
par.trans <- round(c(exp(par[1]),exp(par[2]),exp(par[3]),exp(par[4]),exp(par[5])),3)
par.trans



# HELP FUNCTION TO VISUALIZE THE MODEL FITTING
plot_model_fit <- function(x){
  # get model output given the parameters in "x"
  model_out <- get_model_output(x)
  # get model score POSSON LOG LIKELIHOOD
  L<-matrix(0,nrow=length(case_dt$cases),ncol=1)
  
  #Obtains the likelihood from the model
  L<-dpois(case_dt$cases_ag1,model_out$I1[1:length(case_dt$cases)]*pop_size*report_rate,log=TRUE)
  
  #Log likelihood
  LL<-sum((1-(L==-Inf))*L,na.rm=TRUE)
  
  #Negative log likelihood
  NLL<--LL
  model_score <- NLL
  
  # plot reference data
  plot(case_dt$week,
       case_dt$cases_ag1,
       ylim = c(0,max(case_dt$cases_ag1)*1.2),type = "b",pch=19,
       xlim=c(0,500),
       main = paste('NLL:',round(model_score,digits = 2),
                                 "b:",par.trans[1],
                                 "a:",par.trans[2],
                                 "phi:",par.trans[3],
                                 "t_shift:",par.trans[4],
                                 "nu:",par.trans[5]))
  # plot initial model
  lines(model_out$time,model_out$I1*pop_size*report_rate,col=2,lwd=1,type = "b")
}

plot_model_fit(opt_param_sa)


#[1]  0.6004835 -0.1221676  1.3674025  5.8583174 -3.2601691 #NLL:6863.6
 # ~ 1.82300000   0.88500000   3.92514170 350.13450006   0.03838191
#1.81809030  0.82631195  3.96459003 90.76895906  0.03642838
# [1]   1.87345939   0.97943156   2.99637269 254.24983006   0.03329303 
# [1]   1.83636241   0.85147689   3.34478512 458.66374805   0.03570705
#[1]   1.91130578  0.99921739  3.44664899 95.42278310  0.03679449

################################# #

  
```

